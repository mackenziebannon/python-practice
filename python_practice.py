# -*- coding: utf-8 -*-
"""python_practice.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cHuGtlP83mGNIW-q2CXyLlPzVbNYSXV0

writing functions that accept any number of arguments:
"""

# to write a function that accepts any # of positional arguments, use *
# in this example, rest is a tuple of all extra positional arguments passed (the code treats it as a sequence when performing subsequent calculations)

def avg(first, *rest): 
  return (first + sum(rest)) / (1 + len(rest))

print(avg(1, 2))
print(avg(1, 2, 3, 4))

# to accept any # of keyword arguments, use an arg that starts with **

# create HTML elements, name = element name, value = text inside element, attrs=attributes given to the element (i.e. )
# here, attrs is a dictionary that holds the passed keyword arguments (if any)
import html

def make_element(name, value, **attrs):
    keyvals = [' %s="%s"' % item for item in attrs.items()]
    attr_str = ''.join(keyvals)
    element = '<{name}{attrs}>{value}</{name}>'.format(name=name,attrs=attr_str,value=html.escape(value))
    return element

make_element('div','this is a div')

# for a function that can accept both any number of positional and keyword-only args
# use * and ** together

def anyargs(*args, **kwargs):
  print(args)                   # a tuple
  print(kwargs)                 # a dict

anyargs('argument', test='keyword')

# the * arg can only appear as the last positional argument in a function def
# the ** arg can only appear as the last argument
# arguments can still appear after a * argument

def a(x, *args, y):
  pass

def b(x, *args, y, **kwargs):
  pass

"""writing functions that only accept keyword arguments"""

# function that only accepts certain arguments by keyword
# implement by placing keyword arguments after a * argument or single unnamed *, i.e.:

def recv(maxsize, *, block):
  'receives a message'
  pass
# recv(1024, True) -> returns a TypeError
recv(1024, block=True)

# can also use this technique to specify keyword args for functs that accept a varying # of positional args, i.e.:

# returns the smallest number of an inputted set of values unless a clip is specified, if the clip is larger than the smallest value return the clip
# this function specifies keyword arguments for functions that accept a varying number of positional arguments
# this makes it more clear what an argument means if the person using the function is not familiar with the specifics of the function, so by having to say clip=x, it makes it more clear for the user

def minimum(*values,clip=None):
  m = min(values)
  if clip is not None:
    m = clip if clip > m else m
  return m

minimum(1, 5, 2, -5, 10)
minimum(1, 5, 2, -5, 10, clip=0)

# you would like to attach some additional info to the args so that others know more about how a function is supposed to be used:
# the python interpreter doesn't attach any semantic meaning to attached annotations, they aren't type checks and don't make python behave differently, they can gfive hints to olthers reeading the source code about what you had in mind

def add(x:int, y:int) -> int:
  return x + y

add(2, 3)

help(add)

# function annotations are stored in a function's __annotations__ attribute
add.__annotations__

# returning multiple values from a function
# simple solution: return a tuple (not actually returning multiple variables)

def myfun():
  return 1, 2, 3

a, b, c = myfun()
print(a,b,c)

"""defining functions with default args:"""

# function/method where one of the arguments are option and has a default value

def spam(a, b=42):
  print(a,b)

spam(1)
spam(1, 2)

# if the default value is supposed to be a mutable container (list, set, dictionary, etc), use None as the default

#using a list as a default value
def spam1(a, b=None):
  if b is None:
    b = []
  print(a,b)

spam1(2)